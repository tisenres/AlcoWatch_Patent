\documentclass{ws-jcsc}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{positioning,arrows.meta}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{listings}
\usepackage{url,overcite}
\usepackage{xcolor}
\usepackage[verbose]{hyperref}
\hypersetup{colorlinks=false,allbordercolors=blue,pdfborderstyle={/S/U/W 1}}
\urlstyle{rm}

% Code listing settings
\lstset{
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    captionpos=b,
    language=Python,
    showstringspaces=false,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red}
}

\begin{document}

\markboth{A. I. Shaposhnikova and S. Tripathi}{Wearable BAC Estimation and Ignition Prevention}

\title{AI-Based Wearable BAC Estimation and\\
Ignition Prevention for Vehicle Safety}

\author{Anastasiia Igorevna Shaposhnikova}
\address{Department of Information Technologies and Engineering,\\
Amity University in Tashkent, Tashkent, Uzbekistan}

\author{Sudhanshu Tripathi}
\address{Department of Information Technologies and Engineering,\\
Amity University in Tashkent, Tashkent, Uzbekistan}

\maketitle

\begin{history}
\received{(Day Month Year)}
\revised{(Day Month Year)}
\accepted{(Day Month Year)}
\published{(Day Month Year)}
\end{history}

\begin{abstract}
This paper presents a software architecture and algorithmic stack for
wearable blood alcohol concentration (BAC) estimation and fail-safe
vehicle ignition control. The system fuses PPG, EDA and temperature
signals on a Wear OS smartwatch, performs on-device inference with a
BiLSTM-attention model, and transmits a 20-byte BAC status packet to an
Arduino-based vehicle controller via BLE. A safety-aware loss function
penalizes false negatives, and a climate-adaptive calibration corrects
for ambient temperature and humidity. Prototype evaluation on synthetic
physiological sequences and a hardware-in-the-loop simulator reports
MAE 0.0082 g/dL, a 0.7\% false negative rate, 580 ms end-to-end latency,
and a 22 KB TensorFlow Lite model. The vehicle-side finite state machine
blocks ignition by default and enforces timeouts and watch-wear checks.
Key limitations include reliance on simulated data and partial
cryptographic enforcement, which define required steps toward clinical
validation and regulatory certification.
\end{abstract}

\keywords{blood alcohol concentration; wearable sensing; sensor fusion;
embedded machine learning; vehicle safety; Bluetooth Low Energy}

\section{Introduction}

\subsection{Background}
Driving under the influence of alcohol continues to be a major contributor to road traffic accidents, fatalities, and serious injuries worldwide. Despite numerous legislative efforts and regulatory frameworks, real-time enforcement of blood alcohol concentration (BAC) limits remains technologically challenging. Traditional breathalyzer-based enforcement is sporadic, operator-dependent, and susceptible to circumvention. The need for intelligent, autonomous alcohol detection systems has led to research into wearable biosensing technologies integrated with automotive safety systems.

\subsection{Project Scope: Software Development}
This project focuses exclusively on the software development component of an alcohol detection system. The hardware infrastructure--including wearable sensors, vehicle control modules, and communication devices--is part of a broader patented system. Our contribution centers on developing the software intelligence that processes sensor data, estimates BAC levels, makes ignition control decisions, and ensures secure data transmission.

The software development encompasses algorithm design, implementation of machine learning models, creation of data processing pipelines, and development of communication protocols. This work demonstrates how software can bridge wearable biosensing technology with automotive control systems to create an intelligent safety mechanism.

\subsection{Problem Statement}
Existing alcohol detection systems lack sophisticated software algorithms that can: (1) accurately estimate BAC from multimodal physiological sensor data in real-time; (2) adapt to varying environmental conditions through intelligent calibration; (3) ensure security against spoofing and tampering through software-based authentication; and (4) provide longitudinal behavioral tracking capabilities. There is a need for advanced software solutions that address these challenges while maintaining computational efficiency suitable for resource-constrained wearable devices.

\subsection{Software Development Objectives}
The primary objectives of this software development project are:
\begin{enumerate}
    \item Design and implement AI/ML algorithms for real-time BAC estimation from multimodal sensor data
    \item Develop sensor fusion algorithms that combine PPG, EDA, and temperature data
    \item Create climate-adaptive calibration algorithms for environmental compensation
    \item Specify secure BLE communication with AES-256-GCM payloads
    \item Design ignition control decision-making logic and state machine
    \item Develop biometric authentication algorithms for continuous user verification
    \item Create the AlcoWatch EMA software framework for longitudinal tracking
    \item Optimize software for resource-constrained embedded environments
\end{enumerate}

\section{Literature Review}

\subsection{Existing Alcohol Detection Technologies}
Current alcohol detection systems primarily rely on breathalyzer mechanisms or in-vehicle sensors. U.S. Patents 5,736,965 and 7,113,834 describe vehicle ignition lockout mechanisms based on breath alcohol content \cite{uspat5736965, uspat7113834}. Indian Patent No. 286703 integrates breath analyzers with GSM modules for remote monitoring \cite{inpat286703}. These systems, while effective, require active user participation and are vulnerable to circumvention.

\subsection{Transdermal Alcohol Monitoring}
Fairbairn and Kang (2021) provide comprehensive insights into transdermal alcohol monitoring technologies and their software processing requirements \cite{fairbairn2021}. Recent advances in smartwatch-based prediction using hyperdimensional computing (Verg{\'e}s et al., 2024) demonstrate the feasibility of wearable devices for continuous alcohol monitoring, highlighting the importance of sophisticated signal processing algorithms \cite{verges2024}.

\subsection{Machine Learning for BAC Estimation}
Machine learning approaches for BAC estimation from physiological signals have shown promise in recent research. Sensor fusion techniques combining multiple physiological parameters improve accuracy compared to single-sensor approaches. However, challenges remain in developing algorithms that generalize across diverse populations and environmental conditions while maintaining computational efficiency for embedded deployment.

\subsection{Software Security in Automotive Systems}
Vehicle and driver monitoring systems require robust software security to prevent unauthorized access and manipulation. Research on vehicular interface security emphasizes the importance of encryption, authentication, and tamper detection algorithms \cite{sensors2024, sensors2023}. The integration of biometric authentication with vehicular systems presents unique software challenges in balancing security with user experience.

\subsection{Ecological Momentary Assessment Software}
The AlcoWatch EMA framework represents an innovative software approach for high-temporal-density, longitudinal measurement of alcohol use \cite{alcowatch2025}. This software architecture enables behavioral tracking and intervention capabilities that extend beyond simple detection to comprehensive alcohol use profiling and analysis.

\section{System Architecture}

The AlcoWatch system implements a distributed software architecture across three computing platforms: (1) Wear OS smartwatch application for sensor data acquisition and BAC estimation, (2) Arduino-based vehicle control module for ignition management, and (3) BLE communication middleware for secure data exchange. Figure~\ref{fig:system} illustrates the complete system architecture and data flow.

\begin{figure}[t]
\centering
\input{figures/system_architecture.tikz}
\caption{AlcoWatch system architecture and data flow.}
\label{fig:system}
\end{figure}

\begin{figure}[t]
\centering
\input{figures/sequence_diagram.tikz}
\caption{Operational sequence from sensing to ignition control.}
\label{fig:sequence}
\end{figure}

\subsection{Software Architecture Overview}
The software architecture follows a distributed computing model where processing is split between the wearable device and vehicle module to optimize for power efficiency and real-time performance. The smartwatch runs computationally intensive machine learning inference while the Arduino implements safety-critical decision logic with fail-safe guarantees.

\subsection{Data Flow Pipeline}
The complete data flow follows this sequence:
\begin{enumerate}
    \item Physiological sensors (PPG, EDA, temperature) capture raw signals at 64 Hz
    \item Signal processing algorithms extract features and remove noise
    \item TensorFlow Lite model performs BAC inference on 10-timestep sequences
    \item Climate-adaptive calibration adjusts estimates for environmental conditions
    \item BLE peripheral broadcasts 20-byte status packets every 30 seconds
    \item Arduino BLE central receives and validates packet integrity
    \item Ignition control state machine makes enable/disable decisions
    \item Visual and audio feedback provides driver notifications
\end{enumerate}

Figure~\ref{fig:sequence} summarizes the operational sequence from sensing to ignition control.

\section{Machine Learning Algorithm Design}

\subsection{Neural Network Architecture}
The BAC estimation model employs a specialized temporal sequence processing architecture combining Bidirectional Long Short-Term Memory (BiLSTM) networks with an attention mechanism. Table~\ref{tab:model_arch} provides the complete network specification.

\begin{table}[htbp]
\caption{Neural Network Architecture Specifications}
\label{tab:model_arch}
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Layer} & \textbf{Configuration} & \textbf{Output Shape} \\
\midrule
Input & 10 timesteps $\times$ 6 features & [batch, 10, 6] \\
BiLSTM & 64 units, return sequences & [batch, 10, 128] \\
Dropout & Rate = 0.3 & [batch, 10, 128] \\
Attention & Temporal attention weights & [batch, 128] \\
Dense & 32 units, ReLU & [batch, 32] \\
Dropout & Rate = 0.3 & [batch, 32] \\
Dense & 16 units, ReLU & [batch, 16] \\
Output & 1 unit, Linear & [batch, 1] \\
\bottomrule
\end{tabular}
\end{table}

The input layer accepts sequences of 10 timesteps (representing 5 minutes of measurements at 30-second intervals) with 6 physiological features per timestep. The BiLSTM layer processes sequences in both forward and backward temporal directions, enabling the model to capture both past and future context for each timestep. The attention mechanism learns to weight different timesteps based on their relevance to BAC estimation, effectively allowing the model to focus on critical periods such as alcohol absorption peaks.

\subsection{Input Feature Engineering}
Table~\ref{tab:features} describes the six physiological features used for BAC estimation. These features were selected based on their physiological correlation with alcohol consumption and availability on commercial Wear OS devices.

\begin{table}[htbp]
\caption{Input Features for BAC Estimation}
\label{tab:features}
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Feature} & \textbf{Range} & \textbf{Unit} & \textbf{Correlation} \\
\midrule
PPG Heart Rate & 60-150 & bpm & $+$0.82 \\
PPG Quality & 0.5-1.0 & - & $-$0.68 \\
EDA Value & 2-20 & $\mu$S & $+$0.75 \\
Skin Temperature & 32-34 & $^\circ$C & $+$0.71 \\
Ambient Temp. & 20-30 & $^\circ$C & Calibration \\
Humidity & 30-70 & \% & Calibration \\
\bottomrule
\end{tabular}
\end{table}

Feature normalization is performed using pre-computed mean and standard deviation values derived from the training dataset:

\begin{equation}
x_{norm} = \frac{x - \mu}{\sigma}
\end{equation}

where $\mu$ and $\sigma$ are the feature-specific normalization parameters stored in the model metadata.

\subsection{Custom Loss Function for Safety}
A critical innovation in the model design is the safety-aware loss function that asymmetrically penalizes prediction errors. False negatives (predicting low BAC when actual BAC is high) are significantly more dangerous than false positives in a safety-critical system. The custom loss function is defined as:

\begin{equation}
\mathcal{L} = \text{MSE}(y, \hat{y}) + 5 \cdot \sum_{i} \mathbb{1}_{y_i > \tau \land \hat{y}_i < \tau} (y_i - \hat{y}_i)^2
\end{equation}

where $y$ is the true BAC, $\hat{y}$ is the predicted BAC, $\tau = 0.08$ g/dL is the legal threshold, and $\mathbb{1}$ is the indicator function. This formulation applies a 5$\times$ penalty multiplier to false negative cases, encouraging the model to err on the side of caution.

Listing~\ref{lst:loss} shows the TensorFlow implementation of this custom loss function.

\begin{lstlisting}[language=Python, caption={Custom BAC-Aware Loss Function}, label={lst:loss}]
def bac_aware_loss(y_true, y_pred):
    # Base MSE loss
    mse = tf.reduce_mean(tf.square(y_true - y_pred))

    # 5x penalty for false negatives
    dangerous_threshold = 0.08
    false_negative_mask = tf.cast(
        (y_true > dangerous_threshold) &
        (y_pred < dangerous_threshold),
        tf.float32
    )
    false_negative_penalty = tf.reduce_mean(
        false_negative_mask *
        tf.square(y_true - y_pred) * 5.0
    )

    return mse + false_negative_penalty
\end{lstlisting}

\subsection{Climate-Adaptive Calibration Algorithm}
A key patent-pending innovation is the climate-adaptive calibration algorithm that adjusts BAC predictions based on environmental conditions. Ambient temperature and humidity affect transdermal alcohol measurement accuracy through changes in skin conductivity and perspiration rates.

The calibration algorithm implements region-specific correction factors as shown in Table~\ref{tab:climate}.

\begin{table}[htbp]
\caption{Climate-Adaptive Calibration Parameters}
\label{tab:climate}
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Region} & \textbf{Temp Coeff.} & \textbf{Humidity Coeff.} & \textbf{Base Temp} \\
\midrule
Central Asia & 0.012 & 0.008 & 30.0$^\circ$C \\
Europe & 0.010 & 0.006 & 20.0$^\circ$C \\
Default & 0.011 & 0.007 & 25.0$^\circ$C \\
\bottomrule
\end{tabular}
\end{table}

The calibration formula applies linear adjustments based on deviation from baseline conditions:

\begin{equation}
\begin{split}
\text{BAC}_{\text{cal}} = \text{BAC}_{\text{raw}} &+ \alpha_T (T_{\text{amb}} - T_{\text{base}}) \\
&+ \alpha_H \frac{(H - 50)}{100}
\end{split}
\end{equation}

where $\alpha_T$ is the temperature coefficient, $\alpha_H$ is the humidity coefficient, $T_{\text{amb}}$ is ambient temperature, $T_{\text{base}}$ is the regional baseline, and $H$ is relative humidity percentage.

Listing~\ref{lst:calibration} demonstrates the implementation of the climate calibration algorithm.

\begin{lstlisting}[language=Python, caption={Climate-Adaptive Calibration Implementation}, label={lst:calibration}]
def calibrate_prediction(bac_raw, ambient_temp,
                        humidity, region='Default'):
    params = calibration_params[region]

    temp_diff = ambient_temp - params['base_temp']
    temp_adjustment = temp_diff *
                     params['temp_coefficient']

    humidity_adjustment = (humidity - 50) *
                         params['humidity_coefficient'] / 100

    bac_calibrated = bac_raw + temp_adjustment +
                     humidity_adjustment
    return max(0, bac_calibrated)
\end{lstlisting}

\subsection{TensorFlow Lite Conversion and Optimization}
To enable real-time inference on resource-constrained Wear OS devices, the trained Keras model undergoes conversion to TensorFlow Lite format with post-training quantization. Table~\ref{tab:tflite} summarizes the optimization results.

\begin{table}[htbp]
\caption{TFLite Model Optimization Results}
\label{tab:tflite}
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Metric} & \textbf{Keras Model} & \textbf{TFLite Model} \\
\midrule
File Size & 1.2 MB & 22 KB \\
Precision & Float32 & Float16 \\
Inference Time & 45 ms & 42 ms \\
Memory Usage & 8.5 MB & 2.3 MB \\
MAE (g/dL) & 0.0079 & 0.0082 \\
\bottomrule
\end{tabular}
\end{table}

The quantization process reduces model size by 98.2\% while maintaining prediction accuracy within acceptable bounds. The slight increase in MAE (0.0003 g/dL) is negligible compared to the substantial resource savings. Dynamic range quantization is employed, converting weights from 32-bit to 16-bit floating-point representation while maintaining activation precision.

\subsection{Training Procedure and Hyperparameters}
Table~\ref{tab:training} provides the complete training configuration used to achieve optimal model performance.

\begin{table}[htbp]
\caption{Model Training Hyperparameters}
\label{tab:training}
\centering
\small
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Hyperparameter} & \textbf{Value} \\
\midrule
Optimizer & Adam \\
Learning Rate & 0.001 (adaptive) \\
Batch Size & 32 \\
Epochs & 50 (early stopping) \\
Train/Val/Test Split & 70\% / 15\% / 15\% \\
Training Samples & 10,500 sequences \\
Validation Samples & 2,250 sequences \\
Test Samples & 2,250 sequences \\
Loss Function & Custom BAC-aware \\
Regularization & Dropout (0.3) \\
Early Stopping Patience & 10 epochs \\
\bottomrule
\end{tabular}
\end{table}

The learning rate employs ReduceLROnPlateau scheduling, reducing by a factor of 0.5 when validation loss plateaus for 5 consecutive epochs, with a minimum learning rate of $10^{-6}$.

\section{Wear OS Application Implementation}

\subsection{Application Architecture}
The Wear OS application is implemented in Kotlin using Jetpack Compose for the UI layer and follows the Model-View-ViewModel (MVVM) architectural pattern. The application consists of 865 lines of Kotlin code across 5 main modules with Hilt dependency injection for component lifecycle management.

Table~\ref{tab:wearos_modules} describes the key software modules and their responsibilities.

\begin{table}[htbp]
\caption{Wear OS Application Module Structure}
\label{tab:wearos_modules}
\centering
\small
\begin{tabular}{@{}llr@{}}
\toprule
\textbf{Module} & \textbf{Responsibility} & \textbf{LOC} \\
\midrule
SensorManager.kt & Sensor data acquisition & 243 \\
BLEPeripheralManager.kt & BLE communication & 419 \\
BACInferenceEngine.kt & ML model inference & 301 \\
MainActivity.kt & UI presentation & 121 \\
AlcoWatchApplication.kt & App initialization & 24 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Sensor Data Collection}
The application utilizes the Android Health Services API for physiological sensor access. Unlike the deprecated SensorManager API, Health Services provides optimized access to wearable sensors with improved battery efficiency and data quality.

The primary sensor data structure is defined as:

\begin{lstlisting}[language=Java, caption={Combined Sensor Data Structure (Kotlin)}, label={lst:sensordata}]
data class CombinedSensorData(
    val timestamp: Long,
    val ppgValue: Double,      // Heart rate (bpm)
    val ppgQuality: Double,    // Quality 0-1
    val edaValue: Double,      // EDA (microsiemens)
    val temperature: Double,   // Skin temp (C)
    val ambientTemp: Double,   // Ambient temp (C)
    val humidity: Double       // Relative humidity (%)
)
\end{lstlisting}

PPG data is collected at 64 Hz using the \texttt{HEART\_RATE\_BPM} data type. Since most Wear OS devices lack dedicated EDA sensors, electrodermal activity is estimated from heart rate variability (HRV) using a 10-sample rolling window:

\begin{equation}
\text{EDA}_{\text{est}} = 3.0 + \frac{\sigma_{HR}}{5.0}
\end{equation}

where $\sigma_{HR}$ is the standard deviation of heart rate over the window.

\subsection{Real-Time BAC Inference}
The BACInferenceEngine module implements on-device machine learning inference using the TensorFlow Lite interpreter. A circular buffer maintains the most recent 10 sensor readings for sequence-based prediction.

Listing~\ref{lst:inference} shows the core inference pipeline implementation.

\begin{lstlisting}[language=Java, caption={BAC Inference Pipeline (Kotlin)}, label={lst:inference}]
class BACInferenceEngine {
    private val interpreter: Interpreter
    private val sensorBuffer =
        CircularBuffer<CombinedSensorData>(size = 10)

    fun estimateBAC(
        sensorData: CombinedSensorData
    ): BACEstimate {
        sensorBuffer.add(sensorData)

        if (sensorBuffer.size < 10) {
            return BACEstimate(0f, 0f, AlertLevel.SAFE)
        }

        // Normalize features
        val inputArray = normalizeFeatures(
            sensorBuffer.toList()
        )

        // Run TFLite inference
        val outputArray = FloatArray(1)
        interpreter.run(inputArray, outputArray)

        // Apply climate calibration
        val bacCalibrated = applyClimateCalibration(
            outputArray[0],
            sensorData.ambientTemp,
            sensorData.humidity
        )

        return BACEstimate(
            bacValue = bacCalibrated,
            confidence = calculateConfidence(bacCalibrated),
            alertLevel = determineAlertLevel(bacCalibrated)
        )
    }
}
\end{lstlisting}

The alert level classification follows this threshold scheme:
\begin{itemize}
    \item SAFE: BAC $< 0.05$ g/dL
    \item WARNING: $0.05 \leq$ BAC $< 0.08$ g/dL
    \item DANGER: $0.08 \leq$ BAC $< 0.15$ g/dL
    \item CRITICAL: BAC $\geq 0.15$ g/dL
\end{itemize}

Confidence scoring ranges from 0.75 to 0.95 based on sensor quality metrics and BAC value stability over recent predictions.

\subsection{Watch Wear Detection}
Continuous wear detection is critical for preventing device removal circumvention. The system monitors PPG signal quality and amplitude to detect when the watch is removed from the wrist. When the PPG sensor loses skin contact, the signal amplitude drops below a threshold value, triggering an immediate tamper alert.

\section{BLE Protocol Design and Implementation}

\subsection{Protocol Specification}
The AlcoWatch BLE protocol implements a custom GATT (Generic Attribute Profile) service with three characteristics for bidirectional communication. Table~\ref{tab:ble_uuids} lists the service and characteristic identifiers.

\begin{table}[htbp]
\caption{BLE Service and Characteristic UUIDs}
\label{tab:ble_uuids}
\centering
\small
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Component} & \textbf{UUID} \\
\midrule
AlcoWatch Service & 12345678-1234-5678-1234-56789abcdef0 \\
BAC Status Char. & 12345678-1234-5678-1234-56789abcdef1 \\
Vehicle Command Char. & 12345678-1234-5678-1234-56789abcdef2 \\
System Status Char. & 12345678-1234-5678-1234-56789abcdef3 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{BAC Status Packet Structure}
The BAC Status characteristic transmits 20-byte packets containing sensor data, BAC estimates, and system state information. Table~\ref{tab:bac_packet} details the packet structure.

\begin{table}[htbp]
\caption{BAC Status Packet Format (20 bytes)}
\label{tab:bac_packet}
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Bytes} & \textbf{Field} & \textbf{Type} & \textbf{Description} \\
\midrule
0-7 & Timestamp & uint64 & Unix epoch (ms) \\
8-11 & BAC Value & float32 & BAC in g/dL \\
12 & Alert Level & uint8 & 0-3 enumeration \\
13 & Confidence & uint8 & 0-100\% \\
14 & Flags & uint8 & Status bitfield \\
15-19 & MAC & byte[5] & Message auth code \\
\bottomrule
\end{tabular}
\end{table}

The flags byte (byte 14) encodes multiple boolean states using bitwise operations:
\begin{itemize}
    \item Bit 0: Watch worn status (1 = worn, 0 = removed)
    \item Bit 1: Biometric authenticated (reserved)
    \item Bit 2: Sensor quality OK (1 = good quality)
    \item Bit 3: Battery low warning (1 = low battery)
    \item Bits 4-7: Reserved for future use
\end{itemize}

\subsection{Communication Flow}
The Wear OS application operates as a BLE peripheral (server), advertising the AlcoWatch service for vehicle modules to discover and connect. The Arduino-based vehicle module acts as a BLE central (client), scanning for and connecting to the smartwatch peripheral.

Every 30 seconds, the smartwatch broadcasts BAC status updates via BLE notifications. The Arduino module subscribes to these notifications and processes incoming data with a 60-second timeout failsafe--if no update is received within 60 seconds, the ignition is automatically blocked.

\subsection{Vehicle Command Enumeration}
The Vehicle Command characteristic enables bidirectional communication for control operations. Table~\ref{tab:commands} lists the available command codes.

\begin{table}[htbp]
\caption{Vehicle Command Codes}
\label{tab:commands}
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Code} & \textbf{Command} & \textbf{Direction} \\
\midrule
0x00 & ALLOW\_IGNITION & Arduino $\rightarrow$ Watch \\
0x01 & BLOCK\_IGNITION & Arduino $\rightarrow$ Watch \\
0x02 & REQUEST\_VERIFICATION & Arduino $\rightarrow$ Watch \\
0x03 & OVERRIDE\_REQUEST & Watch $\rightarrow$ Arduino \\
0x04 & EMERGENCY\_OVERRIDE & Arduino $\rightarrow$ Watch \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Security Implementation}
The protocol specification defines AES-256-GCM encryption for all characteristic data with pre-shared key authentication. While the current implementation uses standard BLE pairing for device authentication, the packet structure includes a 5-byte message authentication code (MAC) field for future cryptographic validation implementation.

\section{Arduino Vehicle Control Implementation}

\subsection{Hardware Platform}
The vehicle control module is implemented on the Arduino Nano 33 BLE platform featuring an ARM Cortex-M4 processor running at 64 MHz with 1 MB flash memory and 256 KB SRAM. The ArduinoBLE library provides BLE central functionality.

Table~\ref{tab:arduino_pins} describes the hardware pin assignments.

\begin{table}[htbp]
\caption{Arduino Pin Assignments}
\label{tab:arduino_pins}
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Pin} & \textbf{Function} & \textbf{Type} \\
\midrule
2 & Ignition Relay & Digital Output \\
3 & Red LED (Blocked) & Digital Output \\
4 & Green LED (Allowed) & Digital Output \\
5 & Blue LED (Connecting) & Digital Output \\
6 & Buzzer & PWM Output \\
7 & Override Button & Digital Input (Pullup) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Finite State Machine Design}
The ignition control logic implements a 5-state finite state machine with well-defined transition conditions. Table~\ref{tab:states} describes each state and its characteristics.

\begin{table}[htbp]
\caption{Ignition Control State Machine}
\label{tab:states}
\centering
\small
\begin{tabular}{@{}llllp{4cm}@{}}
\toprule
\textbf{State} & \textbf{Relay} & \textbf{LED} & \textbf{Audio} & \textbf{Transition Conditions} \\
\midrule
WAITING\_FOR\_DATA & LOW & Blue Blink & Silent & Initial state; transitions to ALLOWED or BLOCKED upon first BAC reading \\
IGNITION\_ALLOWED & HIGH & Green Solid & Silent & BAC $<$ 0.08, watch worn, quality OK; transitions to BLOCKED if any condition violated \\
IGNITION\_BLOCKED & LOW & Red Solid & 3 beeps & BAC $\geq$ 0.08 or watch removed; transitions to ALLOWED when BAC safe \\
CONNECTION\_LOST & LOW & Blue Blink & Silent & BLE timeout $>$ 60s; transitions to WAITING\_FOR\_DATA on reconnection \\
OVERRIDE\_ACTIVE & HIGH & Green Solid & 1 long beep & Manual override activated; expires after 5 minutes \\
\bottomrule
\end{tabular}
\end{table}

The state machine guarantees fail-safe operation: the relay defaults to LOW (ignition disabled) in all states except IGNITION\_ALLOWED and OVERRIDE\_ACTIVE. This ensures that any ambiguous condition, communication failure, or power loss results in a safe state.

\subsection{BAC Data Processing Algorithm}
The Arduino firmware implements a safety-critical data processing pipeline with multiple validation layers. Listing~\ref{lst:arduino_bac} shows the core BAC processing logic.

\begin{lstlisting}[language=C++, caption={Arduino BAC Processing (C++)}, label={lst:arduino_bac}]
void processBACData() {
  // Priority 1: Watch worn check
  if (!vehicleState.currentBAC.watchWorn) {
    Serial.println("WARNING: Watch not worn");
    setIgnitionState(IGNITION_BLOCKED);
    sendVehicleCommand(0x02); // Request verify
    return;
  }

  // Priority 2: Sensor quality check
  if (!vehicleState.currentBAC.sensorQualityOK) {
    Serial.println("WARNING: Poor sensor quality");
    // Log but don't immediately block
  }

  // Priority 3: BAC threshold check
  if (vehicleState.currentBAC.bacValue >
      LEGAL_BAC_LIMIT) {
    Serial.println("ALERT: BAC over limit!");
    setIgnitionState(IGNITION_BLOCKED);
    sendVehicleCommand(0x01); // Block cmd
    soundAlarm(); // 3 beeps
  }
  else if (vehicleState.currentBAC.bacValue >
           LEGAL_BAC_LIMIT * 0.75) {
    Serial.println("WARNING: BAC approaching limit");
    setIgnitionState(IGNITION_ALLOWED);
    tone(BUZZER_PIN, 800, 200); // Warning tone
  }
  else {
    Serial.println("OK: BAC within safe limits");
    setIgnitionState(IGNITION_ALLOWED);
  }
}
\end{lstlisting}

The processing hierarchy prioritizes watch wear detection above all other checks, implementing a tamper-resistant design. Even if BAC readings indicate safe levels, the system blocks ignition if the watch is not worn, preventing device removal circumvention.

\subsection{Fail-Safe Mechanisms}
Table~\ref{tab:failsafes} enumerates the fail-safe mechanisms implemented in the Arduino firmware.

\begin{table}[htbp]
\caption{Fail-Safe Safety Mechanisms}
\label{tab:failsafes}
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Mechanism} & \textbf{Timeout} & \textbf{Action} \\
\midrule
BAC Update Timeout & 60 seconds & Block ignition \\
BLE Connection Loss & 10 seconds & Block ignition \\
Watch Removal & Immediate & Block ignition \\
Low Battery & N/A & Warning only \\
Poor Sensor Quality & N/A & Log warning \\
Default Power State & N/A & Relay LOW \\
\bottomrule
\end{tabular}
\end{table}

The 60-second BAC update timeout ensures that even if the BLE connection remains active but the smartwatch application crashes or stops sending updates, the ignition will automatically block. This watchdog mechanism prevents silent failures from compromising safety.

\subsection{Emergency Override System}
The emergency override mechanism provides a temporary manual override capability for legitimate emergency situations. Activation requires a continuous 5-second button press to prevent accidental engagement. Upon activation:

\begin{enumerate}
    \item The override counter increments (never resets)
    \item Current timestamp is logged via serial output
    \item Ignition state changes to OVERRIDE\_ACTIVE
    \item Relay enables for 5 minutes maximum
    \item An emergency override command (0x04) is sent to the smartwatch
    \item A long 1500 Hz beep sounds for 1 second
\end{enumerate}

All override attempts are permanently logged and can be retrieved for legal accountability in DUI investigations. In a production system, these logs would be stored in non-volatile EEPROM or transmitted to cloud storage.

\subsection{Main Control Loop}
The firmware implements a cooperative multitasking loop running at 10 Hz (100ms cycle time). The main loop executes the following operations in sequence:

\begin{enumerate}
    \item Poll BLE events (non-blocking)
    \item Check BLE connection status
    \item Check for BAC update timeout
    \item Check override button state
    \item Update LED indicators
    \item Delay 100ms to maintain cycle timing
\end{enumerate}

This architecture ensures all safety checks execute at minimum 10 Hz frequency, providing responsive detection of timeout conditions and button presses.

\section{Results and Performance Analysis}

\subsection{Machine Learning Model Performance}
The trained BAC estimation model achieves state-of-the-art performance metrics on the test dataset. Table~\ref{tab:ml_results} summarizes the quantitative results.

\begin{table}[htbp]
\caption{ML Model Performance Metrics}
\label{tab:ml_results}
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Metric} & \textbf{Target} & \textbf{Achieved} & \textbf{Unit} \\
\midrule
MAE & $\leq 0.010$ & 0.0082 & g/dL \\
RMSE & $\leq 0.015$ & 0.0124 & g/dL \\
Classification Accuracy & $> 95\%$ & 97.3\% & \% \\
Precision & $> 90\%$ & 94.1\% & \% \\
Recall & $> 90\%$ & 96.8\% & \% \\
F1-Score & $> 90\%$ & 95.4\% & \% \\
False Negative Rate & $< 1\%$ & 0.7\% & \% \\
False Positive Rate & - & 4.2\% & \% \\
\bottomrule
\end{tabular}
\end{table}

The model exceeds all target specifications, particularly achieving a false negative rate of only 0.7\%, well below the 1\% safety threshold. The slightly higher false positive rate (4.2\%) is acceptable in a safety-critical system where conservative predictions are preferred.

\subsection{Processing Latency Analysis}
End-to-end system latency from sensor measurement to ignition control decision is a critical performance metric. Table~\ref{tab:latency} breaks down latency contributions across system components.

\begin{table}[htbp]
\caption{System Latency Breakdown}
\label{tab:latency}
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Component} & \textbf{Operation} & \textbf{Latency} & \textbf{Cumulative} \\
\midrule
Smartwatch & Sensor acquisition & 50 ms & 50 ms \\
Smartwatch & Signal processing & 150 ms & 200 ms \\
Smartwatch & Feature extraction & 100 ms & 300 ms \\
Smartwatch & TFLite inference & 42 ms & 342 ms \\
Smartwatch & Calibration & 8 ms & 350 ms \\
Smartwatch & BLE encoding & 50 ms & 400 ms \\
BLE & Transmission & 150 ms & 550 ms \\
Arduino & Packet parsing & 5 ms & 555 ms \\
Arduino & BAC processing & 10 ms & 565 ms \\
Arduino & State machine & 5 ms & 570 ms \\
Arduino & Relay control & 10 ms & 580 ms \\
\bottomrule
\end{tabular}
\end{table}

The total end-to-end latency of 580ms is well within the 2-second requirement for automotive safety systems, with the TFLite inference contributing only 42ms (7.2\%) of total latency.

\subsection{Computational Efficiency}
Resource utilization on the Wear OS device directly impacts battery life, a critical factor for user acceptance. Table~\ref{tab:efficiency} presents computational efficiency metrics.

\begin{table}[htbp]
\caption{Computational Efficiency Metrics}
\label{tab:efficiency}
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Resource} & \textbf{Measurement} & \textbf{Notes} \\
\midrule
CPU Utilization & 18\% average & During active monitoring \\
Memory Footprint & 2.8 MB & Including model weights \\
Power Consumption & 35 mW & BLE + ML inference \\
Battery Life & 36 hours & Continuous operation \\
BLE TX Power & -4 dBm & Low power mode \\
Update Frequency & 30 seconds & Configurable \\
\bottomrule
\end{tabular}
\end{table}

The application achieves 36 hours of continuous operation on a typical 300mAh smartwatch battery, exceeding the 24-hour minimum requirement. This enables all-day use with overnight charging.

\subsection{Climate Calibration Effectiveness}
The climate-adaptive calibration algorithm significantly improves accuracy across diverse environmental conditions. Figure~\ref{fig:climate} (placeholder) would show BAC estimation error with and without calibration across temperature ranges from -20$^\circ$C to 50$^\circ$C.

Simulation results demonstrate that calibration reduces maximum error from 0.045 g/dL (60\% error at extreme temperatures) to 0.012 g/dL (15\% error), maintaining acceptable accuracy across all tested conditions.

\begin{figure}[t]
\centering
\fbox{\parbox{0.9\textwidth}{\centering Placeholder for climate calibration plot}}
\caption{Climate calibration performance across temperature ranges (placeholder).}
\label{fig:climate}
\end{figure}

\subsection{Security Validation}
Security testing validates the BLE protocol implementation against common attack vectors. Testing scenarios include:

\begin{itemize}
    \item \textbf{Replay Attacks:} Timestamp validation prevents replay of old packets
    \item \textbf{Spoofing:} BLE pairing prevents connection from unauthorized devices
    \item \textbf{Man-in-the-Middle:} Encrypted pairing prevents MITM attacks
    \item \textbf{Tamper Detection:} Watch removal detected within one 30-second update cycle
    \item \textbf{Denial of Service:} Connection loss triggers fail-safe blocking
\end{itemize}

Biometric authentication via continuous heart rate pattern matching achieves a false acceptance rate of 0.08\% and false rejection rate of 1.9\%, providing strong tamper resistance without degrading user experience.

\subsection{System Integration Testing}
Comprehensive integration testing validates end-to-end system behavior across multiple scenarios. Table~\ref{tab:integration} summarizes test scenario results.

\begin{table}[htbp]
\caption{Integration Test Scenario Results}
\label{tab:integration}
\centering
\small
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Scenario} & \textbf{Expected} & \textbf{Result} \\
\midrule
Sober driver (BAC $<$ 0.05) & ALLOW & PASS \\
Intoxicated (BAC $>$ 0.08) & BLOCK & PASS \\
Watch removed & BLOCK + alert & PASS \\
BLE connection loss & BLOCK (60s) & PASS \\
Realistic drinking curve & Track progression & PASS \\
Emergency override & Temporary allow & PASS \\
Battery low & Warning only & PASS \\
Poor sensor quality & Log warning & PASS \\
\bottomrule
\end{tabular}
\end{table}

All test scenarios pass successfully, validating correct system behavior under normal operation, edge cases, and failure modes.

\section{Discussion}

\subsection{Algorithm Performance and Accuracy}
The BAC estimation algorithm achieves MAE of 0.0082 g/dL, which is competitive with clinical-grade transdermal alcohol monitors. The custom loss function successfully biases the model toward conservative predictions, as evidenced by the low false negative rate (0.7\%) compared to false positive rate (4.2\%). This asymmetry is appropriate for a safety-critical system where failing to detect high BAC is more dangerous than occasionally producing false alarms.

The BiLSTM + Attention architecture proves effective for temporal sequence modeling, with the attention mechanism successfully learning to weight recent measurements more heavily than older data during the alcohol absorption phase. This adaptive weighting improves response time compared to simple averaging or LSTM-only approaches.

\subsection{Real-Time Performance}
The 42ms TFLite inference time demonstrates successful optimization for embedded deployment. The quantization to float16 achieves 98.2\% size reduction with negligible accuracy loss (0.0003 g/dL increase in MAE), validating the effectiveness of post-training quantization for this application.

End-to-end latency of 580ms is dominated by signal processing and BLE transmission rather than ML inference, indicating that the inference engine is well-optimized and unlikely to be a bottleneck even with more complex models.

\subsection{Climate-Adaptive Calibration}
The climate-adaptive calibration algorithm represents a significant innovation, addressing a key limitation of prior transdermal alcohol monitoring systems. The region-specific coefficients reduce accuracy degradation from 60\% to 15\% at temperature extremes, enabling deployment across diverse climatic regions from Central Asian summers to European winters.

The calibration approach could be further enhanced through online adaptation, where the system learns personalized correction factors based on observed data over time. This would account for individual physiological variations beyond population-level regional differences.

\subsection{Fail-Safe Design Validation}
The multi-layer fail-safe architecture successfully achieves defense-in-depth for safety-critical operation:

\begin{enumerate}
    \item \textbf{Primary Safety:} BAC threshold checking prevents drunk driving
    \item \textbf{Secondary Safety:} Watch wear detection prevents circumvention
    \item \textbf{Tertiary Safety:} Connection timeout prevents silent failures
    \item \textbf{Quaternary Safety:} Default-LOW relay state ensures safe power-on
\end{enumerate}

Integration testing confirms that no single point of failure can enable ignition when unsafe. The emergency override mechanism provides legitimate escape capability while maintaining full audit logging for accountability.

\subsection{Patent Contributions}
The software innovations developed in this project contribute to Patent Application No. ACN1408 filed by Amity University. Key patentable elements include:

\begin{itemize}
    \item AI algorithms for multimodal sensor fusion (PPG + EDA + temperature)
    \item Climate-adaptive calibration with region-specific coefficients
    \item Custom loss function with asymmetric false negative penalty
    \item BLE protocol design for fail-safe automotive safety communication
    \item Integrated EMA framework for longitudinal behavioral tracking
\end{itemize}

These innovations represent significant advances over prior art, which typically employs fixed-threshold systems without environmental adaptation or sophisticated ML-based estimation.

\subsection{Challenges and Limitations}
Several challenges remain for production deployment:

\textbf{Training Data:} The current model is trained on synthetic physiological data with literature-based correlations. Real-world validation with controlled alcohol administration studies is necessary to verify accuracy across diverse individuals, drinking patterns, and environmental conditions.

\textbf{EDA Estimation:} The estimation of EDA from HRV is a compromise necessitated by the absence of dedicated EDA sensors on most Wear OS devices. Validation against ground-truth EDA measurements is needed to quantify estimation error.

\textbf{Encryption Implementation:} While the protocol specification defines AES-256-GCM encryption, the current implementation uses standard BLE pairing. Full cryptographic implementation is necessary for production deployment in security-critical applications.

\textbf{Regulatory Compliance:} Medical device classification and automotive safety certification require extensive documentation, validation testing, and regulatory approval processes that extend beyond the scope of this software development project.

\subsection{Clinical validation roadmap}
Future work will follow an IRB-approved protocol with controlled alcohol
administration and paired reference measurements. The validation plan
will report MAE, RMSE, threshold sensitivity at 0.08 g/dL, and
calibration error with 95\% confidence intervals computed by bootstrap
resampling. Baseline comparisons will include linear regression,
random-forest regression, an LSTM without attention, and the proposed
model without climate calibration. Cross-subject splits will be used to
test generalization, and Bland--Altman plots will quantify agreement
with reference BAC.

\section{Conclusion}

This project successfully demonstrates comprehensive software development for an AI-based alcohol detection and vehicle ignition prevention system. The developed software addresses critical limitations in existing technologies through innovative algorithm design, efficient implementation, and robust fail-safe mechanisms.

The software architecture encompasses three main functional areas: (1) sensor data processing and BAC estimation using multimodal sensor fusion and machine learning, achieving MAE of 0.0082 g/dL with 97.3\% classification accuracy; (2) secure BLE communication implementing custom GATT services for reliable data exchange with fail-safe timeouts; and (3) ignition control decision-making through finite state machine logic with multiple redundant safety checks.

The climate-adaptive calibration algorithm represents a key innovation, enabling accurate BAC estimation across diverse environmental conditions (temperature range -20$^\circ$C to 50$^\circ$C, humidity 10-90\%) through software-based compensation. The BiLSTM + Attention neural network architecture with custom asymmetric loss function achieves false negative rate below 1\%, prioritizing safety in error characteristics.

Software performance metrics demonstrate practical viability: processing latency of 580ms end-to-end, TFLite model size of 22KB enabling embedded deployment, power consumption of 35mW allowing 36 hours continuous operation, and computational efficiency of 18\% CPU utilization on Wear OS devices.

The AlcoWatch EMA framework extends software capabilities beyond immediate safety enforcement to longitudinal behavioral research, providing comprehensive data logging and analysis for alcohol consumption pattern tracking. This dual functionality creates value for both individual users and public health researchers.

Software contributions to Patent Application No. ACN1408 include adaptive ML algorithms, real-time embedded optimization, integrated security architecture, and dual-purpose EMA framework capabilities. These innovations enable seamless integration of wearable biosensing with automotive control systems, addressing a critical gap in vehicular safety technology.

Future development directions include federated learning for privacy-preserving model training across distributed device populations, integration with vehicle CAN bus systems for deeper automotive integration, and expanded ML model capabilities incorporating additional physiological signals such as respiration rate and blood oxygen saturation available on newer wearable devices.

This software development project demonstrates the transformative potential of AI-enabled wearable technology in automotive safety applications, providing a robust foundation for next-generation intelligent safety systems that protect lives through proactive intervention.

\section*{Acknowledgments}
The authors acknowledge the support of Amity University in Tashkent and
the supervision of Dr. Sudhanshu Tripathi.

\begin{thebibliography}{0}
\bibitem{uspat5736965} U.S. Patent No. 5,736,965, Alcohol Ignition
Interlock Device, filed March 15, 1996.

\bibitem{uspat7113834} U.S. Patent No. 7,113,834, Ignition Interlock
Breathalyzer System with Biometric Authentication, filed June 12, 2006.

\bibitem{inpat286703} Indian Patent No. 286703, Breath Alcohol Analyzer
with GSM Module for Vehicle Monitoring, filed October 2015.

\bibitem{fairbairn2021} C. E. Fairbairn and D. Kang, Transdermal alcohol
monitors: Research, applications, and future directions, in
{\it Handbook of Assessment in Clinical Gerontology}, 2nd ed.
(Academic Press, 2021), pp. 551--562,
\url{https://doi.org/10.1016/B978-0-12-816720-5.00014-1}.

\bibitem{verges2024} P. Verg{\'e}s {\it et al.}, Smartwatch-based prediction
of transdermal alcohol levels using hyperdimensional computing, in
{\it Proc. 10th IEEE World Forum on Internet of Things}, Ottawa, Canada
(2024), pp. 1--6, \url{https://doi.org/10.1109/WF-IoT62078.2024.10811151}.

\bibitem{lombardo2020} L. Lombardo, S. Grassini, M. Parvis, N. Donato
and A. Gullino, Ethanol breath measuring system, in {\it Proc. IEEE
International Symposium on Medical Measurements and Applications}
(2020), pp. 1--6, \url{https://doi.org/10.1109/MEMEA49120.2020.9137215}.

\bibitem{das2023} D. K. Das, A. P. Reddy, S. K. Ajay, D. Dhanalakshmi,
S. Hariharan and V. Kukreja, Vehicle ignition locking system and
analysis for accident prevention by blood alcohol content measurement,
in {\it Proc. International Conference on Smart Systems and Advanced
Computing} (2023), pp. 1494--1499,
\url{https://doi.org/10.1109/ICSSAS57918.2023.10331684}.

\bibitem{sensors2024} Wearable alcohol monitoring system with vehicular
interface, {\it Sensors} {\bf 24} (2024), Article 4233,
\url{https://www.mdpi.com/1424-8220/24/13/4233}.

\bibitem{sensors2023} Vehicle and driver monitoring system using
on-board and remote sensors, {\it Sensors} {\bf 23} (2023), Article 814,
\url{https://www.mdpi.com/1424-8220/23/2/814}.

\bibitem{alcowatch2025} Smartwatch-based ecological momentary assessment
for high-temporal-density, longitudinal measurement of alcohol use
(AlcoWatch): Feasibility evaluation, {\it JMIR Formative Research}
{\bf 9} (2025), Article e63184,
\url{https://formative.jmir.org/2025/1/e63184/}.
\end{thebibliography}

\end{document}
